{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    ol: \"ol\",\n    li: \"li\",\n    h3: \"h3\",\n    h4: \"h4\",\n    img: \"img\"\n  }, _provideComponents(), props.components), {ItemLink, RecipeFor} = _components;\n  if (!ItemLink) _missingMdxReference(\"ItemLink\", true);\n  if (!RecipeFor) _missingMdxReference(\"RecipeFor\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      id: \"crafting-cpu\",\n      children: \"Crafting CPU\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Manages a single auto crafting task from start to finish, built of various crafting units.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To be a valid crafting CPU, two rules must be met:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"The CPU must be a cuboid, completely composed of the parts listed above; air or other blocks are not valid.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"The CPU must contain at least 1 storage component.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The crafting CPU as a multi-block only requires a single channel for the\\nentire structure. Crafting co-processors increase the number of tasks the\\ncrafting CPU can perform at once; with no co-processors, the crafting CPU can\\nperform a single task at a time. Storage requirements are moderately\\ncomplicated, and do not follow the usual ME storage math, but for a first\\napproximation, you will need a little over one byte per input item, output\\nitem, or operation.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can name your Crafting CPUs by naming any of the crafting units it is made up of with\\nan \", _jsx(ItemLink, {\n        id: \"inscriber\"\n      }), \" or an Anvil.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To provide patterns to the autocrafting cpus you can use \", _jsx(ItemLink, {\n        id: \"interface\"\n      }), \"\\nor \", _jsx(ItemLink, {\n        id: \"level_emitter\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"components\",\n      children: \"Components\"\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"crafting-unit\",\n      children: \"Crafting Unit\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/large/craftingunit.png\",\n        alt: \"A picture of several crafting units in a crafting CPU.\",\n        width: \"582\",\n        height: \"517\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This particular block provides the CPU with no additional features, but can be used as a \\\"filler\\\" block.\\nIt is the base for crafting the other functional components of a crafting CPU.\"\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"crafting-storage\",\n      children: \"Crafting Storage\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/large/crafting1k.png\",\n        alt: \"A picture of a 1k crafting storage unit.\",\n        width: \"379\",\n        height: \"383\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Provides 1024 bytes of storage for crafting.\"\n    }), \"\\n\", _jsx(RecipeFor, {\n      id: \"1k_crafting_storage\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/large/crafting4k.png\",\n        alt: \"A picture of a 4k crafting storage unit.\",\n        width: \"387\",\n        height: \"387\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Provides 4,096 bytes of storage for crafting.\"\n    }), \"\\n\", _jsx(RecipeFor, {\n      id: \"4k_crafting_storage\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/large/crafting16k.png\",\n        alt: \"A 16k Crafting Storage Unit.\",\n        width: \"379\",\n        height: \"383\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Provides 16,384 bytes of storage for crafting.\"\n    }), \"\\n\", _jsx(RecipeFor, {\n      id: \"16k_crafting_storage\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/large/crafting64k.png\",\n        alt: \"A picture of a 64k Crafting Storage Unit\",\n        width: \"380\",\n        height: \"383\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Provides 65,536 bytes of storage for crafting.\"\n    }), \"\\n\", _jsx(RecipeFor, {\n      id: \"64k_crafting_storage\"\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"co-processor\",\n      children: \"Co-Processor\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/large/craftingco.png\",\n        alt: \"A picture of several Co Processors in a Crafting CPU\",\n        width: \"557\",\n        height: \"517\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Provides additional item delivery from the CPU to the \", _jsx(ItemLink, {\n        id: \"pattern_provider\"\n      }), \" for\\ncrafting.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This can be used to make more assemblers active in parallel for the job, and\\nthus increase overall crafting speed. These only help if your setup has steps\\nproperly separated so the system can run multiple tasks in parallel, or even\\nsplit the same pattern across multiple interfaces.\"\n    }), \"\\n\", _jsx(RecipeFor, {\n      id: \"crafting_accelerator\"\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"crafting-monitor\",\n      children: \"Crafting Monitor\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/large/craftingmonitor.png\",\n        alt: \"A picture of a crafting monitor inside a Crafting CPU.\",\n        width: \"496\",\n        height: \"425\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Displays the top level job and its current progress so you can see what a particular Crafting CPU is currently\\nworking on.\"\n    }), \"\\n\", _jsx(RecipeFor, {\n      id: \"crafting_monitor\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"pattern-provider\",\n      children: \"Pattern Provider\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Recipes need to be encoded into patterns to be usable by crafting CPUs. The encoded patterns need to be put\\ninto pattern providers on the same network as the Crafting CPU itself. When the crafting CPU then\\nneeds to craft the primary result of that pattern, it'll delegate this to the\\npattern provider. Normally, the pattern provider will then push out the\\ningredients to an adjacent block (a \", _jsx(ItemLink, {\n        id: \"molecular_assembler\"\n      }), \" for crafting recipes, for example),\\nand crafting continues once the result enters the network again.\\nThis can be achieved by pushing the crafting result back into the pattern provider,\\nan \", _jsx(ItemLink, {\n        id: \"interface\"\n      }), \" or any other means that would import the crafting result into the network. Molecular\\nassemblers are smart enough to automatically return the crafting result to the same pattern provider that provided\\nthe ingredients.\"]\n    }), \"\\n\", _jsx(RecipeFor, {\n      id: \"pattern_provider\"\n    }), \"\\n\", _jsx(RecipeFor, {\n      id: \"cable_pattern_provider\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"blank-pattern\",\n      children: \"Blank Pattern\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"A blank pattern, once encoded as an \", _jsx(ItemLink, {\n        id: \"crafting_pattern\"\n      }), \"\\nor \", _jsx(ItemLink, {\n        id: \"processing_pattern\"\n      }), \", is used to control\\ncrafting by inserting them into \", _jsx(ItemLink, {\n        id: \"molecular_assembler\"\n      }), \" and \", _jsx(ItemLink, {\n        id: \"pattern_provider\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Patterns can be encoded in the \", _jsx(ItemLink, {\n        id: \"pattern_encoding_terminal\"\n      }), \".\"]\n    }), \"\\n\", _jsx(RecipeFor, {\n      id: \"blank_pattern\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"crafting-patterns\",\n      children: \"Crafting Patterns\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Encoded version of \", _jsx(ItemLink, {\n        id: \"blank_pattern\"\n      }), \" created by using\\nthe \", _jsx(ItemLink, {\n        id: \"pattern_encoding_terminal\"\n      }), \" in \\\"Crafting Mode\\\".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Crafting Recipes are very specific, and automatically have an output\\nassociated with them, these are required to work with a \", _jsx(ItemLink, {\n        id: \"molecular_assembler\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The description of a crafting pattern starts with \\\"Crafts\\\".\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"processing-recipes\",\n      children: \"Processing Recipes\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Encoded version of \", _jsx(ItemLink, {\n        id: \"blank_pattern\"\n      }), \" created by using\\nthe \", _jsx(ItemLink, {\n        id: \"pattern_encoding_terminal\"\n      }), \" in \\\"Processing Mode\\\".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Processing recipes are not crafting recipes, they have no rules to their\\ninputs, or outputs, and are used for things like machines or furances, they\\ncan support up to 9 different inputs, and up to 3 diffrent outputs ( these\\noutputs cannot be random chance, each output must still be a 100% chance. )\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The description of a processing pattern starts with \\\"Creates\\\".\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{"title":"Auto-Crafting","sidenav_icon":"ae2:molecular_assembler","item_ids":["ae2:blank_pattern","ae2:crafting_pattern","ae2:processing_pattern","ae2:1k_crafting_storage","ae2:4k_crafting_storage","ae2:16k_crafting_storage","ae2:64k_crafting_storage","ae2:crafting_accelerator","ae2:crafting_monitor","ae2:crafting_unit","ae2:pattern_provider","ae2:cable_pattern_provider"]}},"frontMatter":{"title":"Auto-Crafting","sidenav_icon":"ae2:molecular_assembler","item_ids":["ae2:blank_pattern","ae2:crafting_pattern","ae2:processing_pattern","ae2:1k_crafting_storage","ae2:4k_crafting_storage","ae2:16k_crafting_storage","ae2:64k_crafting_storage","ae2:crafting_accelerator","ae2:crafting_monitor","ae2:crafting_unit","ae2:pattern_provider","ae2:cable_pattern_provider"]},"pagePath":"/features/auto-crafting.md"},"__N_SSG":true}