{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      a: \"a\",\n      h2: \"h2\",\n      table: \"table\",\n      thead: \"thead\",\n      tr: \"tr\",\n      th: \"th\",\n      tbody: \"tbody\",\n      td: \"td\",\n      code: \"code\",\n      em: \"em\",\n      pre: \"pre\",\n      strong: \"strong\",\n      h3: \"h3\",\n      ul: \"ul\",\n      li: \"li\",\n      h4: \"h4\",\n      h1: \"h1\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [\"The Javadocs of the latest unreleased version are available at \", _jsx(_components.a, {\n          href: \"https://appliedenergistics.github.io/javadoc/\",\n          children: \"https://appliedenergistics.github.io/javadoc/\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        id: \"mod-initialization\",\n        children: \"Mod Initialization\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"AE2 offers various extension points for your mod to hook into. The following table lists the API classes that are most\\nrelevant during mod initialization:\"\n      }), \"\\n\", _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Class\"\n            }), _jsx(_components.th, {\n              children: \"Purpose\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.code, {\n                children: \"appeng.api.stacks.AEKeyTypes\"\n              })\n            }), _jsxs(_components.td, {\n              children: [\"Addons can use this class to register custom storage types similar to \", _jsx(_components.code, {\n                children: \"AEItemKey\"\n              }), \" and \", _jsx(_components.code, {\n                children: \"AEFluidKey\"\n              }), \".\"]\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.code, {\n                children: \"appeng.api.networking.GridServices\"\n              })\n            }), _jsx(_components.td, {\n              children: \"Addons can register their own grid-wide services here.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.code, {\n                children: \"appeng.api.movable.BlockEntityMoveStrategies\"\n              })\n            }), _jsx(_components.td, {\n              children: \"Allows mods to register custom strategies for moving block entities in and out of spatial storage.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.code, {\n                children: \"appeng.api.features.GridLinkables\"\n              })\n            }), _jsx(_components.td, {\n              children: \"For working with and adding items that can be linked to a grid in the security station.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.code, {\n                children: \"appeng.api.storage.StorageCells\"\n              })\n            }), _jsx(_components.td, {\n              children: \"For working with and adding items that serve as storage cells for grids.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.code, {\n                children: \"appeng.api.features.Locatables\"\n              })\n            }), _jsx(_components.td, {\n              children: \"For discovering security stations and quantum network bridges based on their unique keys, regardless of location.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.code, {\n                children: \"appeng.api.parts.PartModels\"\n              })\n            }), _jsx(_components.td, {\n              children: \"For registering JSON block models used by custom cable bus parts.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.code, {\n                children: \"appeng.api.features.P2PTunnelAttunement\"\n              })\n            }), _jsx(_components.td, {\n              children: \"For registering new items that attune P2P tunnels to specific types when right-clicked.\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: _jsx(_components.code, {\n                children: \"appeng.api.client.StorageCellModels\"\n              })\n            }), _jsx(_components.td, {\n              children: \"For customizing the models of storage cells when they're inserted into drives or ME chests.\"\n            })]\n          })]\n        })]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"In general, these classes are thread-safe and may be used directly in a mod's constructor or thereafter.\\nOnce initialization of mods has completed however, changes to these registries result in undefined behavior.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Since order of mod initialization on Fabric is undefined, addons that rely on AE2's items and blocks being registered\\nwill need to use the custom entrypoint defined by \", _jsx(_components.code, {\n          children: \"IAEAddonEntrypoint\"\n        }), \". See that classes javadoc for details.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        id: \"item-and-fluid-keys\",\n        children: \"Item and Fluid Keys\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Item and fluid types are represented by keys in AE2. The \", _jsx(_components.code, {\n          children: \"AEKey\"\n        }), \" class is the base for all keys, whether they represent\\nitems (\", _jsx(_components.code, {\n          children: \"AEItemKey\"\n        }), \") or fluids (\", _jsx(_components.code, {\n          children: \"AEFluidKey\"\n        }), \"). Most of AE2s interfaces are generic in that they accept any \", _jsx(_components.code, {\n          children: \"AEKey\"\n        }), \",\\nwhether it is for a fluid or item.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Keys do not have counts since they don't represent a particular amount of items or fluid, they represent the \", _jsx(_components.em, {\n          children: \"type\"\n        }), \"\\nof item or type of fluid. As such, an item key consists of a reference to the \", _jsx(_components.code, {\n          children: \"Item\"\n        }), \" and potential NBT data.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"To represent a stack of some key, AE2 provides the utility class \", _jsx(_components.code, {\n          children: \"GenericStack\"\n        }), \". It consists of a key and an amount.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Each type of key is represented by an instance of \", _jsx(_components.code, {\n          children: \"AEKeyType\"\n        }), \", which is accessible via \", _jsx(_components.code, {\n          children: \"AEKey.getType()\"\n        }), \". It stores\\nsome properties common to all keys of a type (i.e. all item keys, or all fluid keys).\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Keys can be saved to from NBT using \", _jsx(_components.code, {\n          children: \"toTagGeneric\"\n        }), \", which also stores a reference to their type so that\\n\", _jsx(_components.code, {\n          children: \"AEKey.fromTagGeneric\"\n        }), \" can restore the key of the correct type. The same mechanism can be used for packets with\\n\", _jsx(_components.code, {\n          children: \"AEKey.writeToPacket\"\n        }), \" and \", _jsx(_components.code, {\n          children: \"AEKey.readKey\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Sicne Java 16, the following patter makes it easy to work with generic keys when your code only supports items:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-java\",\n          children: \"if (key instanceof AEItemKey itemKey) {\\n    ItemStack is = itemKey.toStack();\\n    // [...]\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        id: \"grids-and-nodes\",\n        children: \"Grids and Nodes\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"AE2's core systems work by building grids from grid nodes that are created and owned by ingame objects such as block\\nentities or parts. Grids are never created directly. They form and disband automatically by creating grid nodes, and\\nconnecting or disconnecting them.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"NOTE:\"\n        }), \" Grids a purely a server-side concept. They do not exist on the client.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        id: \"node-owners-and-listeners\",\n        children: \"Node Owners and Listeners\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Every node is owned by an in-game object. An owner doesn't need to implement any particular interface. This makes it\\npossible to integrate existing game objects with AE2 without having to introduce a hard dependency on it.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The node uses a listener (\", _jsx(_components.code, {\n          children: \"IGridNodeListener<T>\"\n        }), \") to interact with its owner. Both owner and listener have to be passed\\ntogether to \", _jsx(_components.code, {\n          children: \"IGridHelper\"\n        }), \" to create a node to allow the listener to be reused while still having type-safe access to the\\nowner.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"Example:\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-java\",\n          children: \"class MyBlockEntityListener implements IGridNodeListener<MyBlockEntity> {\\n    public static final MyBlockEntityListener INSTANCE = new MyBlockEntityListener();\\n\\n    @Override\\n    public void onStateChanged(MyBlockEntity nodeOwner, IGridNode node, StateChangeReason reason) {\\n        [...]\\n        // for example: change block state of nodeOwner to indicate state\\n        // send node owner to clients\\n    }\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-java\",\n          children: \"class MyBlockEntity {\\n    // Create node with owner and listener\\n    private final IManagedNode mainNode = api.createManagedNode(\\n            this,\\n            MyBlockEntityListener.INSTANCE\\n    );\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h3, {\n        id: \"managed-grid-nodes\",\n        children: \"Managed Grid Nodes\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.code, {\n          children: \"IGridHelper\"\n        }), \" API offers a \", _jsx(_components.code, {\n          children: \"createManagedNode\"\n        }), \" method to create an \", _jsx(_components.code, {\n          children: \"IManagedGridNode\"\n        }), \". Managed grid nodes simplify\\nthe lifecycle of creating and destroying grid nodes, and can be used to simplify the distinction between server and\\nclient, since they are available on the client-side as well. They will just not create the underlying node if they're\\nbeing used on the client.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Your game object should notify the managed node about the following events:\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"Call \", _jsx(_components.code, {\n            children: \"destroy\"\n          }), \" on the node when your game object is destroyed or its chunk unloaded.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Call \", _jsx(_components.code, {\n            children: \"create\"\n          }), \" when the node can assume the owner is now in-world and ready to make outgoing connections (i.e. on its\\nfirst tick).\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"When your game object loads from NBT data, load the node's stored data using \", _jsx(_components.code, {\n            children: \"loadFromNBT\"\n          }), \". This has to occur before\\nyou call \", _jsx(_components.code, {\n            children: \"create\"\n          }), \".\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"When your game object saves to NBT data, save the node's data using \", _jsx(_components.code, {\n            children: \"saveToNBT\"\n          }), \".\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        id: \"in-world-nodes\",\n        children: \"In-World Nodes\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The main type of grid node are in-world grid nodes. They need to know their location and world when being created with\\n\", _jsx(_components.code, {\n          children: \"IManagedGridNode.create(Level, BlockPos)\"\n        }), \". External connections are automatically attempt to connect with adjacent\\nin-world grid nodes by AE2 itself and do not need further handling.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"In-world nodes can be selectively exposed on specific sides, or on all sides. The exposed sides can be changed after\\nnode creation and will automatically trigger a repathing.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"To expose the actual \", _jsx(_components.code, {\n          children: \"IGridNode\"\n        }), \", it needs to be exposed by \", _jsx(_components.code, {\n          children: \"IManagedGridNode.getNode()\"\n        }), \" through an appropriate way like\\ncapabilities.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        id: \"virtual-nodes\",\n        children: \"Virtual Nodes\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"A special case are virtual nodes, which will not automatically form connection with other nodes. These allow addons to\\nbuild ME networks outside the normal world for various reasons.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"As these do not automatically establish connections, these have to be manually created with by using\\n\", _jsx(_components.code, {\n          children: \"IGridHelper.createGridConnection(IGridNode, IGridNode)\"\n        }), \". Removing a connection requires destroying the \", _jsx(_components.code, {\n          children: \"IGridNode\"\n        }), \",\\nwhich also handles chunk unloading and ensures it leaving no old connections behind.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        id: \"node-services\",\n        children: \"Node Services\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The node's owner can add so-called services to a node, which can be used to add additional functionality or behavior to\\ngrid nodes. Services are represented by an interface that extends from \", _jsx(_components.code, {\n          children: \"IGridService\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Node services are often used by grid services to offer additional functionality to grid nodes that implement a specific\\nservice. These will be described in more detail in the description of the respective grid service.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        id: \"grid-services\",\n        children: \"Grid Services\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Each grid provides several services to machines connected to the grid.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"AE2 provides some services by default (see sub-interfaces of \", _jsx(_components.code, {\n          children: \"IGridService\"\n        }), \"). Addons can register their own services\\nusing \", _jsx(_components.code, {\n          children: \"GridServices\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Services can be retrieved by calling \", _jsx(_components.code, {\n          children: \"IGrid#getService\"\n        }), \" by passing the grid service's interface. For getting AE2's\\ndefault services, \", _jsx(_components.code, {\n          children: \"IGrid\"\n        }), \" offers several convenience methods.\"]\n      }), \"\\n\", _jsx(_components.h4, {\n        id: \"energy\",\n        children: \"Energy\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Service Interface:\"\n        }), \" \", _jsx(_components.code, {\n          children: \"IEnergyService\"\n        })]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This service allows energy to be extracted from and injected into the grid's energy storage (i.e. energy cells, the\\ngrid's internal storage, etc.).\"\n      }), \"\\n\", _jsx(_components.h4, {\n        id: \"ticking\",\n        children: \"Ticking\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Service Interface:\"\n        }), \" \", _jsx(_components.code, {\n          children: \"ITickManager\"\n        }), \"\\n\", _jsx(_components.strong, {\n          children: \"Convenience Getter\"\n        }), \": \", _jsx(_components.code, {\n          children: \"IGrid.getTickManager\"\n        })]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"AE2 offers its grid connected machines an advanced ticking system with the following features:\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Ticking without being a tickable block entity\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Variable tick rates\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Putting devices to sleep if they run out of work\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Waking sleeping devices in reaction to some event (i.e. neighbors changed)\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The grid's \", _jsx(_components.code, {\n          children: \"ITickManager\"\n        }), \" service handles the per-grid aspects of this ticking system. It offers an API to manage the\\nsleep/wake status of grid nodes.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"To participate in the ticking system, your grid node must provide the \", _jsx(_components.code, {\n          children: \"IGridTickable\"\n        }), \"\\ngrid node service. The \", _jsx(_components.code, {\n          children: \"ITickManager\"\n        }), \" reacts to the presence of this service when your grid node joins the grid.\"]\n      }), \"\\n\", _jsx(_components.h4, {\n        id: \"storage\",\n        children: \"Storage\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Service Interface\"\n        }), \": \", _jsx(_components.code, {\n          children: \"IStorageService\"\n        }), \"\\n\", _jsx(_components.strong, {\n          children: \"Convenience Getter\"\n        }), \": \", _jsx(_components.code, {\n          children: \"IGrid.getStorageService\"\n        })]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This service allows nodes to notify listeners about changes to their inventory that are not caused by normal\\nextraction/insertion, such as the external inventories (i.e. chests) changing their content.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Storage in grids is organized in \\\"cells\\\" which model inventories.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"It also implements \", _jsx(_components.code, {\n          children: \"IStorageMonitorable\"\n        }), \" to allow changes to the grid's inventory to be monitored.\"]\n      }), \"\\n\", _jsx(_components.h4, {\n        id: \"auto-crafting\",\n        children: \"Auto-Crafting\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Service Interface\"\n        }), \": \", _jsx(_components.code, {\n          children: \"ICraftingService\"\n        })]\n      }), \"\\n\", _jsx(_components.h4, {\n        id: \"security\",\n        children: \"Security\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Service Interface\"\n        }), \": \", _jsx(_components.code, {\n          children: \"ISecurityService\"\n        })]\n      }), \"\\n\", _jsx(_components.h4, {\n        id: \"pathing\",\n        children: \"Pathing\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Service Interface\"\n        }), \": \", _jsx(_components.code, {\n          children: \"IPathingService\"\n        })]\n      }), \"\\n\", _jsx(_components.h4, {\n        id: \"spatial-io\",\n        children: \"Spatial I/O\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Service Interface\"\n        }), \": \", _jsx(_components.code, {\n          children: \"ISpatialService\"\n        })]\n      }), \"\\n\", _jsx(_components.h2, {\n        id: \"adding-new-upgrades-or-making-upgradable-machines\",\n        children: \"Adding New Upgrades or Making Upgradable Machines\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This will be made available in 10.0.0-beta.3.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Relevant APIs:\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"appeng.api.upgrades.Upgrades\"\n          }), \" for managing upgrade cards and associating them with machines\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"appeng.api.upgrades.UpgradeInventories\"\n          }), \" for creating upgrade inventories for use in upgradable machines or items\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        id: \"custom-upgrade-cards\",\n        children: \"Custom Upgrade Cards\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Each upgrade is unique identified by a registered item (the \\\"upgrade card\\\"). To create a custom upgrade card that\\nbehaves like the existing AE2 cards (i.e. it can be inserted into the network tool's toolbelt), use the\\nutility function \", _jsx(_components.code, {\n          children: \"Upgrades#createUpgradeCardItem\"\n        }), \" to create an item for your card. Remember it's your responsibility\\nto actually register this item, provide an icon and a translation key for it. It will however, show the tooltip for supported machines and support insertion into machines by right-click out of the box.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        id: \"associating-upgrade-cards-with-machines\",\n        children: \"Associating Upgrade Cards with Machines\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"For both cases where your addon adds a custom machine or upgrade card, you need to associate possible upgrades\\nwith potential machines. The \", _jsx(_components.code, {\n          children: \"Upgrades.add\"\n        }), \" method allows you to link an upgrade card (represented by its Item) with\\na Machine (also represented by an item, usually a \", _jsx(_components.code, {\n          children: \"BlockItem\"\n        }), \" or \", _jsx(_components.code, {\n          children: \"IPartItem\"\n        }), \").\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"If there are multiple machines that are treated equally with regard to upgrades, you can pass a translation key to\\nthe \", _jsx(_components.code, {\n          children: \"tooltipGroup\"\n        }), \" parameter. When displaying the tooltip for an upgrade card, all supported machines with the same\\n\", _jsx(_components.code, {\n          children: \"tooltipGroup\"\n        }), \" will be merged into a single line and shown using the translation for the group. This was used\\nfor displaying fluid and item parts as one line, as well as the block/part form of interfaces.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        id: \"making-custom-machines-upgradable\",\n        children: \"Making custom Machines Upgradable\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"You can use the factory class \", _jsx(_components.code, {\n          children: \"UpgradeInventories\"\n        }), \" to create inventories for storing upgrade cards. These\\ninventories will use the provided item to identify which upgrade cards are accepted by the inventory to\\nautomatically prevent incompatible cards from being inserted.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"They also offer convenience methods (see \", _jsx(_components.code, {\n          children: \"IUpgradeInventory\"\n        }), \") to quickly check if an upgrade is present or\\ncount how many upgrades of a type are present.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"For the machine version created by \", _jsx(_components.code, {\n          children: \"forMachine\"\n        }), \", you are responsible for saving the inventory yourself from the\\nchange callback. For the item version created by \", _jsx(_components.code, {\n          children: \"forItem\"\n        }), \", the upgrade inventory will automatically save itself\\nto the provided ´ItemStack` whenever its content changes.\"]\n      }), \"\\n\", _jsx(_components.h1, {\n        id: \"changes-from-117-and-before-to-118\",\n        children: \"Changes from 1.17 and before to 1.18\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"There are large changes to the API in 1.18.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"IAEStack\"\n        }), \", \", _jsx(_components.code, {\n          children: \"IAEItemStack\"\n        }), \" and \", _jsx(_components.code, {\n          children: \"IAEFluidStack\"\n        }), \" have been removed. The API now separates the \\\"what\\\" from the \\\"how much\\\"\\nin that it uses \", _jsx(_components.code, {\n          children: \"AEKey\"\n        }), \" to identify what is being transferred, while a separate method-argument is used for the\\namount.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The mapping is roughly as follows:\"\n      }), \"\\n\", _jsxs(_components.table, {\n        children: [_jsx(_components.thead, {\n          children: _jsxs(_components.tr, {\n            children: [_jsx(_components.th, {\n              children: \"Old Class\"\n            }), _jsx(_components.th, {\n              children: \"New Class\"\n            })]\n          })\n        }), _jsxs(_components.tbody, {\n          children: [_jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"IAEStack\"\n            }), _jsx(_components.td, {\n              children: \"GenericStack, AEKey\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"IAEItemStack\"\n            }), _jsx(_components.td, {\n              children: \"GenericStack, AEItemKey\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"IAEFluidStack\"\n            }), _jsx(_components.td, {\n              children: \"GenericStack, AEFluidKey\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"IStorageChannel\"\n            }), _jsx(_components.td, {\n              children: \"AEKeyType\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"StorageChannels\"\n            }), _jsx(_components.td, {\n              children: \"AEKeyTypes\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"StorageChannels.items()\"\n            }), _jsx(_components.td, {\n              children: \"AEKeyType.items()\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"StorageChannels.fluids()\"\n            }), _jsx(_components.td, {\n              children: \"AEKeyType.fluids()\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"IMEInventory\"\n            }), _jsx(_components.td, {\n              children: \"MEStorage\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"IMEMonitorable\"\n            }), _jsx(_components.td, {\n              children: \"MEMonitorStorage\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"IGuiItem\"\n            }), _jsx(_components.td, {\n              children: \"IMenuItem (Use ItemMenuHost)\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"IPortableCell\"\n            }), _jsx(_components.td, {\n              children: \"IPortableTerminal\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"ICraftingMedium\"\n            }), _jsx(_components.td, {\n              children: \"ICraftingMachine\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"ICellProvider\"\n            }), _jsx(_components.td, {\n              children: \"IStorageProvider\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"getUnitsPerByte\"\n            }), _jsx(_components.td, {\n              children: \"getAmountPerByte\"\n            })]\n          }), _jsxs(_components.tr, {\n            children: [_jsx(_components.td, {\n              children: \"transferFactor\"\n            }), _jsx(_components.td, {\n              children: \"getAmountPerOperation\"\n            })]\n          })]\n        })]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The network inventory is no longer channel specific. It contains items, fluids and potentially keys\\nfrom addons at the same time. This also means \", _jsx(_components.code, {\n          children: \"IStorageMonitorable\"\n        }), \" has become superfluous and was removed.\\n\", _jsx(_components.code, {\n          children: \"IStorageMonitorableAccessor\"\n        }), \" now gives direct access to the storage.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Stack watching has changed to only send the keys for which the stored amount has changed. This was\\ndone since the amounts reported to the watchers were never reliable to begin with, and were never used.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Craftable items are no longer reported as part of the network storage. It has been replaced by\\n\", _jsx(_components.code, {\n          children: \"grid.getCraftingService().getCraftables()\"\n        }), \". \", _jsx(_components.code, {\n          children: \"NoOpKeyFilter\"\n        }), \" is provided in case you want all types of\\nkeys, otherwise there are the convenience filters \", _jsx(_components.code, {\n          children: \"AEItemKey.filter()\"\n        }), \" and \", _jsx(_components.code, {\n          children: \"AEFluidKey.filter()\"\n        }), \" to\\nonly retrieve items or fluids.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Mounting storage into the network storage has been changed. Since storage has been unified across types,\\nthe storage service will now call \", _jsx(_components.code, {\n          children: \"mountInventories\"\n        }), \" on the \", _jsx(_components.code, {\n          children: \"IStorageProvider\"\n        }), \" service provided by any\\ngrid node and allow the node to \\\"mount\\\" storage into the network.\\nWhen the node wants to remove or add storage due to an external event or config change, it can request\\nthe storage to repeat the mounting process by calling \", _jsx(_components.code, {\n          children: \"IStorageGrid.refreshNodeStorageProvider\"\n        }), \" or using\\nthe utility provided in \", _jsx(_components.code, {\n          children: \"IStorageProvider.requestUpdate\"\n        }), \". This supersedes sending the \", _jsx(_components.code, {\n          children: \"GridCellArrayUpdate\"\n        }), \" event.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        id: \"internal-apis\",\n        children: \"Internal APIs\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The following changes have been made to internal APIs, which may still be of interest to addons that\\ndepend on them.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Items that open AE GUIs are now more addon friendly. The \", _jsx(_components.code, {\n          children: \"ItemMenuHost\"\n        }), \" class can be used as an easy\\nway to implement a menu host for hosting terminals and other menus.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The priority and crafting confirm menus now use a generic system for returning to the previous screen.\\nYour part, block entity or item menu host needs to implement \", _jsx(_components.code, {\n          children: \"ISubMenuHost\"\n        }), \" for this to work.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Custom storage cells have been simplified, and the same class can be used to create addon storage\\ncells for any stored item key. Due to the storage math still being different for items and fluids,\\nthere are still key-type specific cells, which are all based on the same class \", _jsx(_components.code, {\n          children: \"BasicStorageCell\"\n        }), \",\\nwhich doesn't have a guaranteed API however (this is an improvement for later).\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        id: \"crank\",\n        children: \"Crank\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The crank uses \", _jsx(_components.code, {\n          children: \"ICrankable\"\n        }), \" to inject energy into the block it's attached to, when the player turns the crank.\\nOn Fabric, use \", _jsx(_components.code, {\n          children: \"ICrankable.LOOKUP\"\n        }), \" to expose it on your own blocks if you'd like to allow cranks to inject\\nenergy. On Forge, expose the \", _jsx(_components.code, {\n          children: \"ICrankable.CRANKABLE\"\n        }), \" capability.\\nYou can limit which sides of your block a crank is allowed on by only returning a non-null object for the sides\\nof your block you want to allow it on.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Fabric Example:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-java\",\n          children: \"ICrankable.LOOKUP.registerForBlockEntity(ChargerBlockEntity::getCrankable, AEBlockEntities.CHARGER);\\n\\n[...]\\nclass ChargerBlockEntity {\\n  /**\\n   * Allow cranking from the top or bottom.\\n   */\\n  @Nullable\\n  public ICrankable getCrankable(Direction direction) {\\n    var up = getUp();\\n    if (direction == up || direction == up.getOpposite()) {\\n      return new Crankable();\\n    }\\n    return null;\\n  }\\n\\n  class Crankable implements ICrankable {\\n    @Override\\n    public boolean canTurn() {\\n      return getInternalCurrentPower() < getInternalMaxPower();\\n    }\\n\\n    @Override\\n    public void applyTurn() {\\n      injectExternalPower(PowerUnits.AE, POWER_PER_CRANK_TURN, Actionable.MODULATE);\\n    }\\n  }\\n}\\n\"\n        })\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"Addon and Mod API"}},"frontMatter":{"title":"Addon and Mod API"},"pagePath":"/api.md"},"__N_SSG":true}